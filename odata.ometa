ometa ODataParser <: OMeta { // Cheating
  Number = <digit+>:d -> parseInt(d, 10),
  Text =
    <	(	~'\''
        (	'\\' anything
        |	letter
        )
      )*
    >:text
    -> text
  ,

  QuotedText =
    '\''
    Text:t 
    '\'' -> t
  ,

  OData = (
    (
      PathSegment:model 
      (
        '?'
        ( listOf(`QueryOption, '&'):options
        )
      )?
    ) -> { 
            if(options) {
             model.options = {}
             for(var i in options)
               model.options[options[i].name] = options[i].value;
            }
           return model
         }
    | '/'
  ) 
  ,

  QueryOption = 
      SortOption
    | TopOption
    | SkipOption
    | InlineCountOption
    | FilterByOption
    | OperationParam
  ,

  OperationParam = 
    Text:name '=' Text:value -> { name: name, value: value }
  ,

  SortOption = 
    seq("$orderby=")
    listOf(`SortProperty, ','):properties -> { name: '$orderby', value: { properties: properties }  }
  ,

  SortProperty = 
    PropertyPath:property
    (
      seq(" asc") -> "asc"
    | seq(" desc") -> "desc"
    )?:order
    -> {
         property.order = order;
         return property;
       }
  ,

  TopOption = 
    seq("$top=") Number:value -> { name: "$top", value: value }
  ,

  SkipOption = 
    seq("$skip=") Number:value -> { name: "$skip", value: value }
  ,

  InlineCountOption =
    seq("$inlinecount=") 
    (
      seq("allpages") -> "allpages"
    | seq("none") -> "none"
    | Text -> ""
    ):value -> { name: "$inlinecount", value: value }
  ,

  FilterByOption = 
    seq("$filterby=")
    FilterByExpression:expr -> { name: "$filterby", value: expr }
  ,

  FilterByExpression =
    FilterAndExpression
  ,

  FilterAndExpression =
    FilterAndExpression:lhs
    FilterAndOperand:op
    FilterLogicalExpression:rhs -> [ op, lhs, rhs ]
  | FilterLogicalExpression
  ,

  FilterLogicalExpression =
    FilterLogicalExpression:lhs
    FilterByOperand:op
    FilterAddExpression:rhs -> [op, lhs, rhs ]
  | FilterAddExpression
  ,

  FilterSubExpression =
    FilterSubExpression:lhs
    spaces seq("sub") spaces
    FilterAddExpression:rhs -> [ "sub", lhs, rhs ]
  | FilterAddExpression
  ,

  FilterAddExpression =
    FilterAddExpression:lhs
    spaces seq("add") spaces
    FilterModExpression:rhs -> [ "add", lhs, rhs ]
  | FilterModExpression
  ,

  FilterModExpression =
    FilterModExpression:lhs
    spaces seq("mod") spaces
    FilterDivExpression:rhs -> [ "mod", lhs, rhs ]
  | FilterDivExpression
  ,
  FilterDivExpression =
    FilterDivExpression:lhs
    spaces seq("div") spaces
    FilterMulExpression:rhs -> [ "div", lhs, rhs ]
  | FilterMulExpression
  ,

  FilterMulExpression =
    FilterMulExpression:lhs
    spaces seq("mul") spaces
    FilterByValue:rhs -> [ "mul", lhs, rhs ]
  | FilterByValue
  ,

  FilterByValue = 
     FilterMethodCallExpression
  |  FilterNegateExpression
  | Number
  | QuotedText
  | PropertyPath
  | GroupedPrecedenceExpression
  ,

  GroupedPrecedenceExpression = 
    "(" spaces FilterByExpression:expr spaces ")" -> expr
  ,

  FilterAndOperand =
    spaces
    (
      seq("and")
    | seq("or")
    ):op 
    spaces -> op
  ,

  FilterByOperand =
    spaces
    (
      seq("eq")
    | seq("ne")
    | seq("gt")
    | seq("ge")
    | seq("lt")
    | seq("le")
    ):op 
    spaces -> op
    ,

  FilterNegateExpression = 
    spaces
    seq("not")
    spaces
    (
      FilterByValue
    | '(' spaces FilterByExpression:expr spaces ')' -> expr
    ):value ->  [ "not", value ]
  ,

  FilterMethodCallExpression = 
    (
      SubstringOfMethodCall
    | EndsWithMethodCall 
    | StartsWithMethodCall 
    | LengthMethodCall 
    | IndexOfMethodCall
    | ReplaceMethodCall
    | SubstringMethodCall
    | TolowerMethodCall 
    | ToupperMethodCall 
    | TrimMethodCall 
    | ConcatMethodCall 
    | DayMethodCall 
    | HourMethodCall 
    | MinuteMethodCall 
    | MonthMethodCall 
    | SecondMethodCall 
    | YearMethodCall 
    | RoundMethodCall 
    | FloorMethodCall 
    | CeilingMethodCall 
    | IsOfMethodCall
    ):method -> [ "call", method ]
  ,

  SubstringOfMethodCall = 
    TwoArgMethodCall("substringof")
  ,

  EndsWithMethodCall = 
    TwoArgMethodCall("endswith")
  ,

  StartsWithMethodCall = 
    TwoArgMethodCall("startswith")
  ,

  LengthMethodCall = 
    SingleArgMethodCall("length")
  ,

  IndexOfMethodCall = 
    TwoArgMethodCall("indexof")
  ,
  ReplaceMethodCall = 
    ThreeArgMethodCall("replace")
  ,
  SubstringMethodCall = 
    TwoArgMethodCall("substring")
  | ThreeArgMethodCall("substring")
  ,
  TolowerMethodCall = 
    SingleArgMethodCall("tolower")
  ,
  ToupperMethodCall = 
    SingleArgMethodCall("toupper")
  ,
  TrimMethodCall = 
    SingleArgMethodCall("trim")
  ,
  ConcatMethodCall = 
    SingleArgMethodCall("concat")
  ,
  DayMethodCall = 
    TwoArgMethodCall("day")
  ,
  HourMethodCall = 
    SingleArgMethodCall("hour")
  ,
  MinuteMethodCall = 
    SingleArgMethodCall("minute")
  ,
  MonthMethodCall = 
    SingleArgMethodCall("month")
  ,
  SecondMethodCall = 
    SingleArgMethodCall("second")
  ,
  YearMethodCall = 
    SingleArgMethodCall("year")
  ,
  RoundMethodCall = 
    SingleArgMethodCall("round")
  ,
  FloorMethodCall = 
    SingleArgMethodCall("floor")
  ,
  CeilingMethodCall = 
    SingleArgMethodCall("ceiling")
  ,

  IsOfMethodCall = 
    SingleArgMethodCall("isof")
  | TwoArgMethodCall("isof")
  ,

  SingleArgMethodCall :name =
    seq(name) 
    '(' 
    spaces 
    FilterByExpression:one 
    spaces
    ')' -> { args: [ one ], method: name }
  ,

  TwoArgMethodCall :name = 
    seq(name)
    '(' 
    spaces 
    FilterByExpression:one 
    spaces 
    ',' 
    spaces 
    FilterByExpression:two 
    spaces 
    ')' -> { args: [ one, two ], method: name }
  , 

  ThreeArgMethodCall :name = 
    seq(name)
    '(' 
    spaces 
    FilterByExpression:one 
    spaces 
    ',' 
    spaces 
    FilterByExpression:two 
    spaces 
    ','
    spaces
    FilterByExpression:three 
    spaces 
    ')' -> { args: [ one, two, three ], method: name }
  , 

  PropertyPath = 
          ResourceName:resource
          (
            '/'
            PropertyPath: next
          )? -> { name: resource, property: next}
  ,
  PathSegment = 
        '/'
        ResourceName:resource
        (
          ("(" Number:key ")")?
          (
            (seq("/$links") PathSegment:link)
          | PathSegment: next
          )?
        ) -> { resource: resource, key: key, link: link, property: next }
  ,

  ResourcePart =
    <	(	letter
      |	'_'
      )+
    >:resourcePart
    -> resourcePart.replace(new RegExp('_', 'g'), ' ')
  ,

  ResourceName =
    <	ResourcePart
      (	'-'
        ResourcePart
      )*
    >
}

exports.ODataParser = ODataParser

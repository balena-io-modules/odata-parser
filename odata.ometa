ometa ODataParser <: OMeta { // Cheating
  Number = <digit+>:d -> parseInt(d, 10),
  Text =
    <	(	~'\''
        (	'\\' anything
        |	letter
        )
      )*
    >:text
    -> text
  ,

  QuotedText =
    '\''
    Text:t 
    '\'' -> t
  ,

  OData = (
    (
      PathSegment:model 
      (
        '?'
        ( listOf(`QueryOption, '&'):options
        )
      )?
    ) -> { 
            if(options) {
             model.options = {}
             for(var i in options)
               model.options[options[i].name] = options[i].value;
            }
           return model
         }
    | '/'
  ) 
  ,

  QueryOption = 
      SortOption
    | TopOption
    | SkipOption
    | InlineCountOption
    | FilterByOption
    | OperationParam
  ,

  OperationParam = 
    Text:name '=' Text:value -> { name: name, value: value }
  ,

  SortOption = 
    seq("$orderby=")
    listOf(`SortProperty, ','):properties -> { name: '$orderby', value: { properties: properties }  }
  ,

  SortProperty = 
    PropertyPath:property
    (
      seq(" asc") -> "asc"
    | seq(" desc") -> "desc"
    )?:order
    -> {
         property.order = order;
         return property;
       }
  ,

  TopOption = 
    seq("$top=") Number:value -> { name: "$top", value: value }
  ,

  SkipOption = 
    seq("$skip=") Number:value -> { name: "$skip", value: value }
  ,

  InlineCountOption =
    seq("$inlinecount=") 
    (
      seq("allpages") -> "allpages"
    | seq("none") -> "none"
    | Text -> ""
    ):value -> { name: "$inlinecount", value: value }
  ,

  FilterByOption = 
    seq("$filterby=")
    FilterByExpression:expr -> { name: "$filterby", value: expr }
  ,

  FilterByExpression =
    FilterAndExpression
  ,

  FilterAndExpression =
    FilterAndExpression:lhs
    FilterAndOperand:op
    FilterLogicalExpression:rhs -> [ op, lhs, rhs ]
  | FilterLogicalExpression
  ,

  FilterLogicalExpression =
    FilterLogicalExpression:lhs
    FilterByOperand:op
    FilterAddExpression:rhs -> [op, lhs, rhs ]
  | FilterAddExpression
  ,

  FilterSubExpression =
    FilterSubExpression:lhs
    spaces seq("sub") spaces
    FilterAddExpression:rhs -> [ "sub", lhs, rhs ]
  | FilterAddExpression
  ,

  FilterAddExpression =
    FilterAddExpression:lhs
    spaces seq("add") spaces
    FilterModExpression:rhs -> [ "add", lhs, rhs ]
  | FilterModExpression
  ,

  FilterModExpression =
    FilterModExpression:lhs
    spaces seq("mod") spaces
    FilterDivExpression:rhs -> [ "mod", lhs, rhs ]
  | FilterDivExpression
  ,
  FilterDivExpression =
    FilterDivExpression:lhs
    spaces seq("div") spaces
    FilterMulExpression:rhs -> [ "div", lhs, rhs ]
  | FilterMulExpression
  ,

  FilterMulExpression =
    FilterMulExpression:lhs
    spaces seq("mul") spaces
    FilterByValue:rhs -> [ "mul", lhs, rhs ]
  | FilterByValue
  ,

  FilterByValue = 
    FilterNegateExpression
  | Number
  | QuotedText
  | PropertyPath
  | GroupedPrecedenceExpression
  ,

  GroupedPrecedenceExpression = 
    "(" spaces FilterByExpression:expr spaces ")" -> expr

  ,

  FilterAndOperand =
    spaces
    (
      seq("and")
    | seq("or")
    ):op 
    spaces -> op
  ,

  FilterByOperand =
    spaces
    (
      seq("eq")
    | seq("ne")
    | seq("gt")
    | seq("ge")
    | seq("lt")
    | seq("le")
    ):op 
    spaces -> op
    ,

  FilterNegateExpression = 
    spaces
    seq("not")
    spaces
    (
      FilterByValue
    | '(' spaces FilterByExpression:expr spaces ')' -> expr
    ):value ->  [ "not", value ]
  ,

  PropertyPath = 
          ResourceName:resource
          (
            '/'
            PropertyPath: next
          )? -> { name: resource, property: next}
  ,
  PathSegment = 
        '/'
        ResourceName:resource
        (
          ("(" Number:key ")")?
          (
            (seq("/$links") PathSegment:link)
          | PathSegment: next
          )?
        ) -> { resource: resource, key: key, link: link, property: next }
  ,

  ResourcePart =
    <	(	letter
      |	'_'
      )+
    >:resourcePart
    -> resourcePart.replace(new RegExp('_', 'g'), ' ')
  ,

  ResourceName =
    <	ResourcePart
      (	'-'
        ResourcePart
      )*
    >
}

exports.ODataParser = ODataParser

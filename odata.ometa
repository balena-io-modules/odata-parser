ometa ODataParser <: OMeta { // Cheating as this will break Syntastic etc and make writing this file easier

  OData = (
    (
      PathSegment:model 
      (
        '?'
        ( listOf(`QueryOption, '&'):options
        )
      )?
    ) -> { 
            if(options) {
             model.options = {}
             for(var i in options)
               model.options[options[i].name] = options[i].value;
            }
           return model
         }
    | '/'
  ) 
  ,

  QueryOption = 
      SortOption
    | TopOption
    | SkipOption
    | ExpandOption
    | InlineCountOption
    | FilterByOption
    | FormatOption
    | SelectOption
    | OperationParam
  ,

  OperationParam = 
    Text:name '=' Text:value -> { name: name, value: value }
  ,

  SortOption = 
    seq("$orderby=")
    listOf(`SortProperty, ','):properties -> { name: '$orderby', value: { properties: properties }  }
  ,

  SortProperty = 
    PropertyPath:property
    (
      spaces
      seq("asc")
    | seq("desc")
    | -> 'desc'
    )?:order
    -> {
         property.order = order;
         return property;
       }
  ,

  TopOption = 
    seq("$top=") Number:value -> { name: "$top", value: value }
  ,

  SkipOption = 
    seq("$skip=") Number:value -> { name: "$skip", value: value }
  ,

  InlineCountOption =
    seq("$inlinecount=") 
    (
      seq("allpages") 
    | seq("none")
    | Text -> ""
    ):value -> { name: "$inlinecount", value: value }
  ,

  ExpandOption = 
    seq("$expand=")
    PropertyPathList:properties -> { name: "$expand", value: { properties: properties }}
  ,

  SelectOption =
    seq("$select=")
    (
      "*"                                 -> '*' 
    | PropertyPathList:properties  -> { properties: properties }
    ):value -> { name: "$select", value: value }
  ,


  FilterByOption = 
    seq("$filterby=")
    FilterByExpression:expr -> { name: "$filterby", value: expr }
  ,

  FormatOption = 
    seq("$format=")
    ContentType:type -> { name: "$format", value: type }
  ,

  FilterByExpression =
    FilterAndExpression
  ,

  FilterAndExpression =
    FilterAndExpression:lhs
    FilterAndOperand:op
    FilterLogicalExpression:rhs -> [ op, lhs, rhs ]
  | FilterLogicalExpression
  ,

  FilterLogicalExpression =
    FilterLogicalExpression:lhs
    FilterByOperand:op
    FilterAddExpression:rhs -> [op, lhs, rhs ]
  | FilterAddExpression
  ,

  FilterSubExpression =
    FilterSubExpression:lhs
    spaces seq("sub") spaces
    FilterAddExpression:rhs -> [ "sub", lhs, rhs ]
  | FilterAddExpression
  ,

  FilterAddExpression =
    FilterAddExpression:lhs
    spaces seq("add") spaces
    FilterModExpression:rhs -> [ "add", lhs, rhs ]
  | FilterModExpression
  ,

  FilterModExpression =
    FilterModExpression:lhs
    spaces seq("mod") spaces
    FilterDivExpression:rhs -> [ "mod", lhs, rhs ]
  | FilterDivExpression
  ,
  FilterDivExpression =
    FilterDivExpression:lhs
    spaces seq("div") spaces
    FilterMulExpression:rhs -> [ "div", lhs, rhs ]
  | FilterMulExpression
  ,

  FilterMulExpression =
    FilterMulExpression:lhs
    spaces seq("mul") spaces
    FilterByValue:rhs -> [ "mul", lhs, rhs ]
  | FilterByValue
  ,

  FilterByValue = 
     FilterMethodCallExpression
  |  FilterNegateExpression
  | Number
  | QuotedText
  | PropertyPath
  | GroupedPrecedenceExpression
  ,

  GroupedPrecedenceExpression = 
    "(" spaces FilterByExpression:expr spaces ")" -> expr
  ,

  FilterAndOperand =
    spaces
    (
      seq("and")
    | seq("or")
    ):op 
    spaces -> op
  ,

  FilterByOperand =
    spaces
    (
      seq("eq")
    | seq("ne")
    | seq("gt")
    | seq("ge")
    | seq("lt")
    | seq("le")
    ):op 
    spaces -> op
    ,

  FilterNegateExpression = 
    spaces
    seq("not")
    spaces
    (
      FilterByValue
    | '(' spaces FilterByExpression:expr spaces ')' -> expr
    ):value ->  [ "not", value ]
  ,

  FilterMethodCallExpression = 
    (
      SubstringOfMethodCall
    | EndsWithMethodCall 
    | StartsWithMethodCall 
    | LengthMethodCall 
    | IndexOfMethodCall
    | ReplaceMethodCall
    | SubstringMethodCall
    | TolowerMethodCall 
    | ToupperMethodCall 
    | TrimMethodCall 
    | ConcatMethodCall 
    | DayMethodCall 
    | HourMethodCall 
    | MinuteMethodCall 
    | MonthMethodCall 
    | SecondMethodCall 
    | YearMethodCall 
    | RoundMethodCall 
    | FloorMethodCall 
    | CeilingMethodCall 
    | IsOfMethodCall
    ):method -> [ "call", method ]
  ,

  SubstringOfMethodCall = 
    MethodCall("substringof", 2)
  ,

  EndsWithMethodCall = 
    MethodCall("endswith", 2)
  ,

  StartsWithMethodCall = 
    MethodCall("startswith", 2)
  ,

  LengthMethodCall = 
    MethodCall("length", 1)
  ,

  IndexOfMethodCall = 
    MethodCall("indexof", 2)
  ,
  ReplaceMethodCall = 
    MethodCall("replace", 3)
  ,
  SubstringMethodCall = 
    MethodCall("substring", 2)
  | MethodCall("substring", 3)
  ,
  TolowerMethodCall = 
    MethodCall("tolower", 1)
  ,
  ToupperMethodCall = 
    MethodCall("toupper", 1)
  ,
  TrimMethodCall = 
    MethodCall("trim", 1)
  ,
  ConcatMethodCall = 
    MethodCall("concat", 1)
  ,
  DayMethodCall = 
    MethodCall("day", 2)
  ,
  HourMethodCall = 
    MethodCall("hour", 1)
  ,
  MinuteMethodCall = 
    MethodCall("minute", 1)
  ,
  MonthMethodCall = 
    MethodCall("month", 1)
  ,
  SecondMethodCall = 
    MethodCall("second", 1)
  ,
  YearMethodCall = 
    MethodCall("year", 1)
  ,
  RoundMethodCall = 
    MethodCall("round", 1)
  ,
  FloorMethodCall = 
    MethodCall("floor", 1)
  ,
  CeilingMethodCall = 
    MethodCall("ceiling", 1)
  ,

  IsOfMethodCall = 
    MethodCall("isof", 1)
  | MethodCall("isof", 2)
  ,

  MethodCall :name :arity =
    seq(name)
    '('
      spaces
      numberOf(`FilterByExpression, arity, ','):args
      spaces
    ')' -> { args: args, method: name }
  ,

  PropertyPathList = 
    listOf(`PropertyPath, ',')

 ,
  PropertyPath = 
    ResourceName:resource
    (
      '/'
      PropertyPath: next
    )? -> { name: resource, property: next}
  ,
  PathSegment = 
    '/'
    ResourceName:resource
    (
      ("(" Number:key ")")?
      (
        (seq("/$links") PathSegment:link)
      | PathSegment: next
      )?
    ) -> { resource: resource, key: key, link: link, property: next }
  ,

  ContentType = 
    < letter+
      '/' 
      letter+
      (
        '+' letter+
      )?
    >
  ,

  ResourceName =
    <(	
      ~(ReservedUriComponent | ' ')
      anything
    )+
    >:resourceName -> decodeURIComponent(resourceName)
  ,

  Number = <digit+>:d -> parseInt(d, 10)
  ,

  ReservedUriComponent  =
    GenDelim
  | SubDelim
  ,

  GenDelim = 
    ":" | "/" | "?" | "#" | "[" | "]" | "@"
  ,
  
  SubDelim = 
    "!" | '$' | '*' | "'" | "&" | "(" | ")" | "+" | "," | ";" | "="
  ,

  Text =
    <
     (~ReservedUriComponent
     anything)*
    >:text -> decodeURIComponent(text)
  ,

  QuotedText =
    '\''
    Text:t 
    '\'' -> t
  
}

ODataParser.numberOf = function(rule, count, seperator) {
  var ret = [];
  for(var i = 1; i < count; i++) {
    ret.push(this._apply(rule));
    this._apply("spaces");
    this._applyWithArgs('exactly', seperator)
    this._apply("spaces");
  }
  ret.push(this._apply(rule));
  return ret;
}

exports.ODataParser = ODataParser

export ometa ODataParser {

	Process = OData,

	OData =
			PathSegment:model
			end
			-> model
		|	seq('/$metadata')
			-> {resource: '$metadata'}
		|	'/'
			end
			-> {resource: '$serviceroot'}
	,
	
	QueryOptions =
		'?'
		listOf(`QueryOption, '&'):options
		{{}}:optionsObj
		{	for(var i in options) {
				optionsObj[options[i].name] = options[i].value;
			}
		}
		-> optionsObj
	,

	QueryOption =
			SortOption
		|	TopOption
		|	SkipOption
		|	ExpandOption
		|	InlineCountOption
		|	FilterByOption
		|	FormatOption
		|	SelectOption
		|	OperationParam
	,

	OperationParam =
		Text:name '=' Text:value
		-> { name: name, value: value }
	,

	SortOption =
		RecognisedOption('$orderby=')
		listOf(`SortProperty, ','):properties
		-> { name: '$orderby', value: { properties: properties } }
	,

	SortProperty =
		PropertyPath:property
		spaces
		(	seq('asc')
		|	seq('desc')
		|	-> 'desc'
		):order
		{property.order = order}
		-> property
	,

	TopOption =
		RecognisedOption('$top=')
		Number:value
		-> { name: '$top', value: value }
	,

	SkipOption =
		RecognisedOption('$skip=')
		Number:value
		-> { name: '$skip', value: value }
	,

	InlineCountOption =
		RecognisedOption('$inlinecount=')
		(	seq('allpages')
		|	seq('none')
		|	Text -> ''
		):value
		-> { name: '$inlinecount', value: value }
	,

	ExpandOption =
		RecognisedOption('$expand=')
		PropertyPathList:properties
		-> { name: '$expand', value: { properties: properties } }
	,

	SelectOption =
		RecognisedOption('$select=')
		(	'*'
		|	PropertyPathList:properties
			-> { properties: properties }
		):value
		-> { name: '$select', value: value }
	,


	FilterByOption =
		RecognisedOption('$filter=')
		FilterByExpression:expr
		-> { name: '$filter', value: expr }
	,

	FormatOption =
		RecognisedOption('$format=')
		ContentType:type
		-> { name: '$format', value: type }
	,

	RecognisedOption :name =
		seq(name)
	,

	FilterByExpression =
		FilterAndExpression
	,

	FilterAndExpression =
		FilterAndExpression:lhs
		FilterAndOperand:op
		FilterLogicalExpression:rhs
		(	?(op == lhs[0])
			-> [ op ].concat(lhs.slice(1), [rhs])
		|	-> [ op, lhs, rhs ]
		)
	|	FilterLogicalExpression
	,

	FilterLogicalExpression =
		FilterLogicalExpression:lhs
		FilterByOperand:op
		FilterSubExpression:rhs
		-> [op, lhs, rhs ]
	|	FilterSubExpression
	,

	FilterSubExpression =
		FilterSubExpression:lhs
		spaces FilterRecognisedMathOperand('sub'):op spaces
		FilterAddExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterAddExpression
	,

	FilterAddExpression =
		FilterAddExpression:lhs
		spaces FilterRecognisedMathOperand('add'):op spaces
		FilterModExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterModExpression
	,

	FilterModExpression =
		FilterModExpression:lhs
		spaces FilterRecognisedMathOperand('mod'):op spaces
		FilterDivExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterDivExpression
	,
	FilterDivExpression =
		FilterDivExpression:lhs
		spaces FilterRecognisedMathOperand('div'):op spaces
		FilterMulExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterMulExpression
	,

	FilterMulExpression =
		FilterMulExpression:lhs
		spaces FilterRecognisedMathOperand('mul'):op spaces
		FilterByValue:rhs
		-> [ op, lhs, rhs ]
	|	FilterByValue
	,

	FilterByValue =
		FilterMethodCallExpression
	|	FilterNegateExpression
	|	Number
	|	Null
	|	Boolean
	|	QuotedText
	|	Date
	|	LambdaPropertyPath
	|	PropertyPath
	|	GroupedPrecedenceExpression
	,

	GroupedPrecedenceExpression =
		'(' spaces FilterByExpression:expr spaces ')'
		-> expr
	,

	FilterRecognisedMathOperand :name =
		seq(name)
	,

	FilterAndOperand =
		spaces
		(	seq('and')
		|	seq('or')
		):op
		spaces -> op
	,

	FilterByOperand =
		spaces
		(	seq('eq')
		|	seq('ne')
		|	seq('gt')
		|	seq('ge')
		|	seq('lt')
		|	seq('le')
		):op
		spaces
		-> op
	,

	FilterNegateExpression =
		spaces
		seq('not')
		spaces
		(	FilterByValue
		|	'(' spaces FilterByExpression:expr spaces ')'
			-> expr
		):value
		-> [ 'not', value ]
	,

	FilterMethodCallExpression =
		(	SubstringOfMethodCall
		|	EndsWithMethodCall
		|	StartsWithMethodCall
		|	LengthMethodCall
		|	IndexOfMethodCall
		|	ReplaceMethodCall
		|	SubstringMethodCall
		|	TolowerMethodCall
		|	ToupperMethodCall
		|	TrimMethodCall
		|	ConcatMethodCall
		|	DayMethodCall
		|	HourMethodCall
		|	MinuteMethodCall
		|	MonthMethodCall
		|	SecondMethodCall
		|	YearMethodCall
		|	RoundMethodCall
		|	FloorMethodCall
		|	CeilingMethodCall
		|	IsOfMethodCall
		):method
		-> [ 'call', method ]
	,

	SubstringOfMethodCall =
		MethodCall('substringof', 2)
	,

	EndsWithMethodCall =
		MethodCall('endswith', 2)
	,

	StartsWithMethodCall =
		MethodCall('startswith', 2)
	,

	LengthMethodCall =
		MethodCall('length', 1)
	,

	IndexOfMethodCall =
		MethodCall('indexof', 2)
	,
	ReplaceMethodCall =
		MethodCall('replace', 3)
	,
	SubstringMethodCall =
		MethodCall('substring', 2)
	|	MethodCall('substring', 3)
	,
	TolowerMethodCall =
		MethodCall('tolower', 1)
	,
	ToupperMethodCall =
		MethodCall('toupper', 1)
	,
	TrimMethodCall =
		MethodCall('trim', 1)
	,
	ConcatMethodCall =
		MethodCall('concat', 2)
	,
	DayMethodCall =
		MethodCall('day', 2)
	,
	HourMethodCall =
		MethodCall('hour', 1)
	,
	MinuteMethodCall =
		MethodCall('minute', 1)
	,
	MonthMethodCall =
		MethodCall('month', 1)
	,
	SecondMethodCall =
		MethodCall('second', 1)
	,
	YearMethodCall =
		MethodCall('year', 1)
	,
	RoundMethodCall =
		MethodCall('round', 1)
	,
	FloorMethodCall =
		MethodCall('floor', 1)
	,
	CeilingMethodCall =
		MethodCall('ceiling', 1)
	,

	IsOfMethodCall =
			MethodCall('isof', 1)
		|	MethodCall('isof', 2)
	,

	MethodCall :name :arity =
		seq(name)
		'('
			spaces
			numberOf(`FilterByExpression, arity, ','):args
			spaces
		')'
		-> { args: args, method: name }
	,

	LambdaMethodCall =
		(	seq('any')
		|	seq('all')
		):name
		'('
			spaces
			anything:identifier
			':'
			FilterByExpression:expression
			spaces
		')'
		-> { expression: expression, identifier: identifier, method: name }
	,

	PropertyPathList =
		listOf(`PropertyPath, ',')
	,
	PropertyPath =
		ResourceName:resource
		(	'/'
			PropertyPath:next
		)?
		-> { name: resource, property: next}
	,
	LambdaPropertyPath =
		ResourceName:resource
		'/'
		(	LambdaPropertyPath:next
			-> { name: resource, property: next}
		|	LambdaMethodCall: lambda
			-> { name: resource, lambda: lambda}
		)
	,
	Key =
		'('
		(	Number
		|	QuotedText
		):key
		')'
		-> key
	,
	PathSegment =
		'/'
		ResourceName:resource
		(	Key:key
			(	seq('/$links')
				SubPathSegment:link
			|	SubPathSegment:next
			)?
		)?
		QueryOptions?:options
		-> { resource: resource, key: key, link: link, property: next, options: options }
	,
	SubPathSegment =
		'/'
		ResourceName:resource
		// Really this is only optional if the multiplicity from the previous segment to this segment is at most 1
		Key?:key
		(	seq('/$links')
			SubPathSegment:link
		|	SubPathSegment:next
		)?
		QueryOptions?:options
		-> { resource: resource, key: key, link: link, property: next, options: options }
	,

	ContentType =
		<	letter+
			'/'
			letter+
			('+' letter+)?
		>
	,

	ResourceName =
		<	(
				~(ReservedUriComponent | space)
				anything
			)+
		>:resourceName
		-> decodeURIComponent(resourceName)
	,

	Number =
			Decimal
		|	Integer
	,

	Decimal =
		<	digit+
			'.'
			digit+
		>:d
		-> Number(d)
	,

	Integer =
		<digit+>:d
		-> parseInt(d, 10)
	,

	Null =
		seq('null')
		-> null
	,

	Boolean =
			True
		|	False
	,

	True =
		seq('true')
		-> true
	,

	False =
		seq('false')
		-> false
	,

	Date =
		(	seq('datetime')
		|	seq('date')
		)
		QuotedText:date
		{Date.parse(date)}:date
		?(!isNaN(date))
		-> new Date(date)
	,

	ReservedUriComponent =
			GenDelim
		|	SubDelim
	,

	GenDelim =
		':' | '/' | '?' | '#' | '[' | ']' | '@'
	,

	SubDelim =
		'!' | '$' | '*' | Apostrophe | '&' | '(' | ')' | '+' | ',' | ';' | '='
	,

	Text =
		<	(	~ReservedUriComponent
				anything
			)*
		>:text
		-> decodeURIComponent(text)
	,

	// TODO: This should really be done treating everything the same, but for now this hack should allow FF to work passably.
	Apostrophe =
			'\''
		|	seq('%27')
			-> '\''
	,

	QuotedText =
		Apostrophe
		Text:t
		Apostrophe
		-> t
	,

	space =
			^space
		|	seq('%20')
			-> ' '
}

ODataParser.numberOf = function(rule, count, separator) {
	var ret = [];
	for(var i = 1; i < count; i++) {
		ret.push(this._apply(rule));
		this._apply('spaces');
		this._applyWithArgs('exactly', separator);
		this._apply('spaces');
	}
	ret.push(this._apply(rule));
	return ret;
}

ODataParser._enableTokens = function() {
	OMeta._enableTokens.call(this, ['Text', 'ResourceName', 'Number', 'RecognisedOption', 'FilterAndOperand', 'FilterByOperand', 'FilterRecognisedMathOperand']);
};
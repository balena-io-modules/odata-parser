export ometa ODataParser {

	Process = OData,

	OData =
			PathSegment:model
			end
			-> model
		|	seq('/$metadata')
			-> {resource: '$metadata'}
		|	'/'
			end
			-> {resource: '$serviceroot'}
	,
	
	QueryOptions =
		'?'
		listOf(`QueryOption, '&'):options
		ParseOptionsObject(options)
	,

	QueryOption =
			SortOption
		|	TopOption
		|	SkipOption
		|	ExpandOption
		|	InlineCountOption
                |       CountOption
		|	FilterByOption
		|	FormatOption
		|	SelectOption
		|	OperationParam
	,

	OperationParam =
		Text:name '=' Text:value
		-> { name: name, value: value }
	,

	SortOption =
		RecognisedOption('$orderby=')
		listOf(`SortProperty, ','):properties
		-> { name: '$orderby', value: { properties: properties } }
	,

	SortProperty =
		PropertyPath:property
		spaces
		(	seq('asc')
		|	seq('desc')
		|	-> 'desc'
		):order
		{property.order = order}
		-> property
	,

	TopOption =
		RecognisedOption('$top=')
		UnsignedInteger:value
		-> { name: '$top', value: value }
	,

	SkipOption =
		RecognisedOption('$skip=')
		UnsignedInteger:value
		-> { name: '$skip', value: value }
	,

	InlineCountOption =
		RecognisedOption('$inlinecount=')
		(	seq('allpages')
		|	seq('none')
		|	Text -> ''
		):value
		-> { name: '$inlinecount', value: value }
	,

        CountOption =
                RecognisedOption('$count=')
                (       seq('true')
                |       '*'
                )
                -> { name: '$count', value: '*' }
                |  RecognisedOption('$count')
                   -> { name: '$count', value: '*' }
        ,

	ExpandOption =
		RecognisedOption('$expand=')
		ExpandPropertyPathList:properties
		-> { name: '$expand', value: { properties: properties } }
	,

	SelectOption =
		RecognisedOption('$select=')
		(	'*'
		|	PropertyPathList:properties
			-> { properties: properties }
		):value
		-> { name: '$select', value: value }
	,


	FilterByOption =
		RecognisedOption('$filter=')
		FilterByExpression:expr
		-> { name: '$filter', value: expr }
	,

	FormatOption =
		RecognisedOption('$format=')
		ContentType:type
		-> { name: '$format', value: type }
	,

	RecognisedOption :name =
		seq(name)
	,

	FilterByExpression =
		FilterAndExpression
	,

	FilterAndExpression =
		FilterAndExpression:lhs
		FilterAndOperand:op
		FilterLogicalExpression:rhs
		(	?(op == lhs[0])
			-> [ op ].concat(lhs.slice(1), [rhs])
		|	-> [ op, lhs, rhs ]
		)
	|	FilterLogicalExpression
	,

	FilterLogicalExpression =
		FilterLogicalExpression:lhs
		FilterByOperand:op
		FilterSubExpression:rhs
		-> [op, lhs, rhs ]
	|	FilterSubExpression
	,

	FilterSubExpression =
		FilterSubExpression:lhs
		spaces FilterRecognisedMathOperand('sub'):op spaces
		FilterAddExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterAddExpression
	,

	FilterAddExpression =
		FilterAddExpression:lhs
		spaces FilterRecognisedMathOperand('add'):op spaces
		FilterModExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterModExpression
	,

	FilterModExpression =
		FilterModExpression:lhs
		spaces FilterRecognisedMathOperand('mod'):op spaces
		FilterDivExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterDivExpression
	,
	FilterDivExpression =
		FilterDivExpression:lhs
		spaces FilterRecognisedMathOperand('div'):op spaces
		FilterMulExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterMulExpression
	,

	FilterMulExpression =
		FilterMulExpression:lhs
		spaces FilterRecognisedMathOperand('mul'):op spaces
		FilterByValue:rhs
		-> [ op, lhs, rhs ]
	|	FilterByValue
	,

	FilterByValue =
		FilterMethodCallExpression
	|	FilterNegateExpression
	|	Number
	|	Null
	|	Boolean
	|	QuotedText
	|	Date
	|	Duration
	|	LambdaPropertyPath
	|	PropertyPath
	|	GroupedPrecedenceExpression
	,

	GroupedPrecedenceExpression =
		'(' spaces FilterByExpression:expr spaces ')'
		-> expr
	,

	FilterRecognisedMathOperand :name =
		seq(name)
	,

	FilterAndOperand =
		spaces
		(	seq('and')
		|	seq('or')
		):op
		spaces -> op
	,

	FilterByOperand =
		spaces
		(	seq('eq')
		|	seq('ne')
		|	seq('gt')
		|	seq('ge')
		|	seq('lt')
		|	seq('le')
		):op
		spaces
		-> op
	,

	FilterNegateExpression =
		spaces
		seq('not')
		spaces
		(	FilterByValue
		|	'(' spaces FilterByExpression:expr spaces ')'
			-> expr
		):value
		-> [ 'not', value ]
	,

	FilterMethodCallExpression =
		(	ContainsMethodCall
		|	EndsWithMethodCall
		|	StartsWithMethodCall
		|	LengthMethodCall
		|	IndexOfMethodCall
		|	SubstringMethodCall
		|	ToLowerMethodCall
		|	ToUpperMethodCall
		|	TrimMethodCall
		|	ConcatMethodCall
		|	YearMethodCall
		|	MonthMethodCall
		|	DayMethodCall
		|	HourMethodCall
		|	MinuteMethodCall
		|	SecondMethodCall
		|	FractionalSecondsMethodCall
		|	DateMethodCall
		|	TimeMethodCall
		|	TotalOffsetMinutesMethodCall
		|	NowMethodCall
		|	MaxDateTimeMethodCall
		|	MinDateTimeMethodCall
		|	TotalSecondsMethodCall
		|	RoundMethodCall
		|	FloorMethodCall
		|	CeilingMethodCall
		|	IsOfMethodCall
		|	CastMethodCall
		// OData < v4
		|	SubstringOfMethodCall
		|	ReplaceMethodCall
		):method
		-> [ 'call', method ]
	,

	ContainsMethodCall =
		MethodCall('contains', 2)
	,
	EndsWithMethodCall =
		MethodCall('endswith', 2)
	,
	StartsWithMethodCall =
		MethodCall('startswith', 2)
	,
	LengthMethodCall =
		MethodCall('length', 1)
	,
	IndexOfMethodCall =
		MethodCall('indexof', 2)
	,
	SubstringMethodCall =
		MethodCall('substring', 2)
	|	MethodCall('substring', 3)
	,
	ToLowerMethodCall =
		MethodCall('tolower', 1)
	,
	ToUpperMethodCall =
		MethodCall('toupper', 1)
	,
	TrimMethodCall =
		MethodCall('trim', 1)
	,
	ConcatMethodCall =
		MethodCall('concat', 2)
	,
	YearMethodCall =
		MethodCall('year', 1)
	,
	MonthMethodCall =
		MethodCall('month', 1)
	,
	DayMethodCall =
		MethodCall('day', 1)
	,
	HourMethodCall =
		MethodCall('hour', 1)
	,
	MinuteMethodCall =
		MethodCall('minute', 1)
	,
	SecondMethodCall =
		MethodCall('second', 1)
	,
	FractionalSecondsMethodCall =
		MethodCall('fractionalseconds', 1)
	,
	DateMethodCall =
		MethodCall('date', 1)
	,
	TimeMethodCall =
		MethodCall('time', 1)
	,
	TotalOffsetMinutesMethodCall =
		MethodCall('totaloffsetminutes', 1)
	,
	NowMethodCall =
		MethodCall('now', 0)
	,
	MaxDateTimeMethodCall =
		MethodCall('maxdatetime', 0)
	,
	MinDateTimeMethodCall =
		MethodCall('mindatetime', 0)
	,
	TotalSecondsMethodCall =
		MethodCall('totalseconds', 1)
	,
	RoundMethodCall =
		MethodCall('round', 1)
	,
	FloorMethodCall =
		MethodCall('floor', 1)
	,
	CeilingMethodCall =
		MethodCall('ceiling', 1)
	,
	IsOfMethodCall =
			MethodCall('isof', 1)
		|	MethodCall('isof', 2)
	,
	CastMethodCall =
			MethodCall('cast', 1)
		|	MethodCall('cast', 2)
	,

	SubstringOfMethodCall =
		MethodCall('substringof', 2)
	,
	ReplaceMethodCall =
		MethodCall('replace', 3)
	,

	MethodCall :name :arity =
		seq(name)
		'('
			spaces
			numberOf(`FilterByExpression, arity, ','):args
			spaces
		')'
		-> { args: args, method: name }
	,

	LambdaMethodCall =
		(	seq('any')
		|	seq('all')
		):name
		'('
			spaces
			ResourceName:identifier
			':'
			FilterByExpression:expression
			spaces
		')'
		-> { expression: expression, identifier: identifier, method: name }
	,

	PropertyPathList =
		listOf(`PropertyPath, ',')
	,
	PropertyPath =
		ResourceName:resource
		(	'/'
			PropertyPath:next
		)?
		-> { name: resource, property: next}
	,
	ExpandPropertyPathList =
		listOf(`ExpandPropertyPath, ',')
	,
	ExpandPropertyPath =
		ResourceName:resource
		(	'('
			listOf(`ExpandPathOption, '&'):options
			ParseOptionsObject(options):optionsObj
			')'
		)?
		(	'/'
			PropertyPath:next
		)?
		-> { name: resource, property: next, options: optionsObj}
	,
	ExpandPathOption =
			SortOption
		|	TopOption
		|	SkipOption
		|	ExpandOption
		|	InlineCountOption
		|	FilterByOption
		|	FormatOption
		|	SelectOption
		|	OperationParam
	,

	LambdaPropertyPath =
		ResourceName:resource
		'/'
		(	LambdaPropertyPath:next
			-> { name: resource, property: next}
		|	LambdaMethodCall: lambda
			-> { name: resource, lambda: lambda}
		)
	,
	Key =
		'('
		(	Number
		|	QuotedText
		):key
		')'
		-> key
	,
	PathSegment =
		'/'
		ResourceName:resource
		(	Key:key
			(	seq('/$links')
				SubPathSegment:link
			|	SubPathSegment:next
			)?
		)?
		QueryOptions?:options
		-> { resource: resource, key: key, link: link, property: next, options: options }
	,
	SubPathSegment =
		'/'
		ResourceName:resource
		// Really this is only optional if the multiplicity from the previous segment to this segment is at most 1
		Key?:key
		(	seq('/$links')
			SubPathSegment:link
		|	SubPathSegment:next
		)?
		QueryOptions?:options
		-> { resource: resource, key: key, link: link, property: next, options: options }
	,

	ContentType =
		<	letter+
			'/'
			letter+
			('+' letter+)?
		>
	,

	ResourceName =
		<	(
				~(ReservedUriComponent | space)
				anything
			)+
		>:resourceName
		-> decodeURIComponent(resourceName)
	,

	Number =
			Decimal
		|	Integer
	,

	Decimal =
		Sign:sign
		<	digit+
			'.'
			digit+
		>:d
		-> Number(sign + d)
	,

	Integer =
		Sign:sign
		<digit+>:d
		-> parseInt(sign + d, 10)
	,

	UnsignedInteger =
		<digit+>:d
		-> parseInt(d, 10)
	,

	Null =
		seq('null')
		-> null
	,

	Boolean =
			True
		|	False
	,

	True =
		seq('true')
		-> true
	,

	False =
		seq('false')
		-> false
	,

	Date =
		(	seq('datetime')
		|	seq('date')
		)
		QuotedText:date
		{Date.parse(date)}:date
		?(!isNaN(date))
		-> new Date(date)
	,

	Duration =
		seq('duration')
		Apostrophe
		// Sign must appear first if it appears
		Sign:sign
		// P must always appear
		'P'
		// The order of elements is fixed (PnDTnHnMnS)
		DurationInteger('D')?:day
		(	// T must be present for time parts to be specified
			'T'
			DurationInteger('H')?:hour
			DurationInteger('M')?:minute
			DurationNumber('S')?:second
			// If T is present there must be a time part
			?(hour || minute || second)
		)?:timeExists
		// There must be a duration part
		?(day || timeExists)
		Apostrophe
		-> {
			negative: sign == '-',
			day: day,
			hour: hour,
			minute: minute,
			second: second
		}
	,
	DurationInteger :letter =
		UnsignedInteger:n
		exactly(letter)
		-> n
	,
	DurationNumber :letter =
		(	DurationInteger(letter)
		|	<	digit+
				'.'
				digit+
			>:d
			exactly(letter)
			-> Number(d)
		)
	,

	ReservedUriComponent =
			GenDelim
		|	SubDelim
	,

	GenDelim =
		':' | '/' | '?' | '#' | '[' | ']' | '@'
	,

	SubDelim =
		'!' | '$' | '*' | Apostrophe | '&' | '(' | ')' | '+' | ',' | ';' | '='
	,

	Text =
		<	(	~ReservedUriComponent
				anything
			)*
		>:text
		-> decodeURIComponent(text)
	,

	Sign =
			'+'
		|	seq('%2B')
			-> '+'
		|	'-'
		|	-> ''
	,

	// TODO: This should really be done treating everything the same, but for now this hack should allow FF to work passably.
	Apostrophe =
			'\''
		|	seq('%27')
			-> '\''
	,

	QuotedText =
		Apostrophe
		(	Apostrophe Apostrophe
		|	~Apostrophe
			anything
		)*:text
		Apostrophe
		-> decodeURIComponent(text.join(''))
	,

	space =
			^space
		|	seq('%20')
			-> ' '
}

ODataParser.ParseOptionsObject = function(options) {
	var optionsObj = {};
	for(var i in options) {
		optionsObj[options[i].name] = options[i].value;
	}
	return optionsObj;
}

ODataParser.numberOf = function(rule, count, separator) {
	if(count === 0) {
		return [];
	}
	var ret = [];
	for(var i = 1; i < count; i++) {
		ret.push(this._apply(rule));
		this._apply('spaces');
		this._applyWithArgs('exactly', separator);
		this._apply('spaces');
	}
	ret.push(this._apply(rule));
	return ret;
}

ODataParser._enableTokens = function() {
	OMeta._enableTokens.call(this, ['Text', 'ResourceName', 'Number', 'RecognisedOption', 'FilterAndOperand', 'FilterByOperand', 'FilterRecognisedMathOperand']);
};

var methods = {
	cast: [ 1, 2 ],
	ceiling: 1,
	concat: 2,
	contains: 2,
	date: 1,
	day: 1,
	endswith: 2,
	floor: 1,
	fractionalseconds: 1,
	hour: 1,
	indexof: 2,
	isof: [ 1, 2 ],
	length: 1,
	maxdatetime: 0,
	mindatetime: 0,
	minute: 1,
	month: 1,
	now: 0,
	replace: 3,
	round: 1,
	second: 1,
	startswith: 2,
	substringof: 2,
	substring: [ 2, 3 ],
	time: 1,
	tolower: 1,
	totaloffsetminutes: 1,
	totalseconds: 1,
	toupper: 1,
	trim: 1,
	year: 1
};

export ometa ODataParser {

	Process =
		{this.reset()}
		OData:tree
		-> { tree: tree, binds: this.binds }
	,
	ProcessRule =
		anything:rule
		[	apply(rule):result
		]
		end
		-> result
	,

	OData =
			PathSegment:model
			end
			-> model
		|	seq('/$metadata')
			-> {resource: '$metadata'}
		|	'/'
			end
			-> {resource: '$serviceroot'}
	,

	QueryOptions =
		'?'
		listOf(`QueryOption, '&'):options
		ParseOptionsObject(options)
	,

	QueryOption =
			SortOption
		|	TopOption
		|	SkipOption
		|	ExpandOption
		|	InlineCountOption
		|	CountOption
		|	FilterByOption
		|	FormatOption
		|	SelectOption
		|	OperationParam
	,

	OperationParam =
		Text:name '=' Text:value
		-> { name: name, value: value }
	,

	SortOption =
		RecognisedOption('orderby')
		listOf(`SortProperty, ','):properties
		-> { name: '$orderby', value: { properties: properties } }
	,

	SortProperty =
		PropertyPath:property
		spaces
		(	seq('asc')
		|	seq('desc')
		|	-> 'desc'
		):order
		{property.order = order}
		-> property
	,

	TopOption =
		RecognisedOption('top')
		UnsignedInteger:value
		-> { name: '$top', value: value }
	,

	SkipOption =
		RecognisedOption('skip')
		UnsignedInteger:value
		-> { name: '$skip', value: value }
	,

	InlineCountOption =
		RecognisedOption('inlinecount')
		(	seq('allpages')
		|	seq('none')
		|	Text -> ''
		):value
		-> { name: '$inlinecount', value: value }
	,

	CountOption =
		RecognisedOption('count')
		Boolean:value
		-> { name: '$count', value: value }
	,

	ExpandOption =
		RecognisedOption('expand')
		ExpandPropertyPathList:properties
		-> { name: '$expand', value: { properties: properties } }
	,

	SelectOption =
		RecognisedOption('select')
		(	'*'
		|	PropertyPathList:properties
			-> { properties: properties }
		):value
		-> { name: '$select', value: value }
	,


	FilterByOption =
		RecognisedOption('filter')
		FilterByExpression:expr
		-> { name: '$filter', value: expr }
	,

	FormatOption =
		RecognisedOption('format')
		ContentType:type
		-> { name: '$format', value: type }
	,

	RecognisedOption :name =
		Dollar
		seq(name)
		'='
	,

	FilterByExpression =
		FilterAndExpression
	,

	FilterAndExpression =
		FilterAndExpression:lhs
		FilterAndOperand:op
		FilterLogicalExpression:rhs
		(	?(op == lhs[0])
			-> [ op ].concat(lhs.slice(1), [rhs])
		|	-> [ op, lhs, rhs ]
		)
	|	FilterLogicalExpression
	,

	FilterLogicalExpression =
		FilterLogicalExpression:lhs
		FilterByOperand:op
		FilterSubExpression:rhs
		-> [op, lhs, rhs ]
	|	FilterSubExpression
	,

	FilterSubExpression =
		FilterSubExpression:lhs
		spaces FilterRecognisedMathOperand('sub'):op spaces
		FilterAddExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterAddExpression
	,

	FilterAddExpression =
		FilterAddExpression:lhs
		spaces FilterRecognisedMathOperand('add'):op spaces
		FilterModExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterModExpression
	,

	FilterModExpression =
		FilterModExpression:lhs
		spaces FilterRecognisedMathOperand('mod'):op spaces
		FilterDivExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterDivExpression
	,
	FilterDivExpression =
		FilterDivExpression:lhs
		spaces FilterRecognisedMathOperand('div'):op spaces
		FilterMulExpression:rhs
		-> [ op, lhs, rhs ]
	|	FilterMulExpression
	,

	FilterMulExpression =
		FilterMulExpression:lhs
		spaces FilterRecognisedMathOperand('mul'):op spaces
		FilterByValue:rhs
		-> [ op, lhs, rhs ]
	|	FilterByValue
	,

	FilterByValue =
		FilterMethodCallExpression
	|	FilterNegateExpression
	|	NumberBind
	|	Null
	|	BooleanBind
	|	QuotedTextBind
	|	DateBind
	|	Duration
	|	LambdaPropertyPath
	|	PropertyPath
	|	GroupedPrecedenceExpression
	,

	GroupedPrecedenceExpression =
		'(' spaces FilterByExpression:expr spaces ')'
		-> expr
	,

	FilterRecognisedMathOperand :name =
		seq(name)
	,

	FilterAndOperand =
		spaces
		(	seq('and')
		|	seq('or')
		):op
		spaces -> op
	,

	FilterByOperand =
		spaces
		(	seq('eq')
		|	seq('ne')
		|	seq('gt')
		|	seq('ge')
		|	seq('lt')
		|	seq('le')
		):op
		spaces
		-> op
	,

	FilterNegateExpression =
		spaces
		seq('not')
		spaces
		(	FilterByValue
		|	'(' spaces FilterByExpression:expr spaces ')'
			-> expr
		):value
		-> [ 'not', value ]
	,

	FilterMethodCallExpression =
		(	seq('cast')
		|	seq('ceiling')
		|	seq('concat')
		|	seq('contains')
		|	seq('date')
		|	seq('day')
		|	seq('endswith')
		|	seq('floor')
		|	seq('fractionalseconds')
		|	seq('hour')
		|	seq('indexof')
		|	seq('isof')
		|	seq('length')
		|	seq('maxdatetime')
		|	seq('mindatetime')
		|	seq('minute')
		|	seq('month')
		|	seq('now')
		|	seq('replace')
		|	seq('round')
		|	seq('second')
		|	seq('startswith')
		|	seq('substringof')
		|	seq('substring')
		|	seq('time')
		|	seq('tolower')
		|	seq('totaloffsetminutes')
		|	seq('totalseconds')
		|	seq('toupper')
		|	seq('trim')
		|	seq('year')

		):methodName
		'('
			spaces
			numberOf(`FilterByExpression, methods[methodName], ','):args
			spaces
		')'
		-> [ 'call', { args: args, method: methodName } ]
	,

	LambdaMethodCall =
		(	seq('any')
		|	seq('all')
		):name
		'('
			spaces
			ResourceName:identifier
			':'
			FilterByExpression:expression
			spaces
		')'
		-> { expression: expression, identifier: identifier, method: name }
	,

	PropertyPathList =
		listOf(`PropertyPath, ',')
	,
	PropertyPath =
		ResourceName:resource
		(	'/'
			PropertyPath:next
		)?
		-> { name: resource, property: next}
	,
	ExpandPropertyPathList =
		listOf(`ExpandPropertyPath, ',')
	,
	ExpandPropertyPath =
		ResourceName:resource
		(	seq('/$count')
			-> true
		)?:count
		(	'('
			listOf(`ExpandPathOption, '&'):options
			ParseOptionsObject(options):optionsObj
			')'
		)?
		(	'/'
			PropertyPath:next
		)?
		-> { name: resource, property: next, count: count, options: optionsObj}
	,
	ExpandPathOption =
			SortOption
		|	TopOption
		|	SkipOption
		|	ExpandOption
		|	InlineCountOption
		|	CountOption
		|	FilterByOption
		|	FormatOption
		|	SelectOption
		|	OperationParam
	,

	LambdaPropertyPath =
		ResourceName:resource
		'/'
		(	LambdaPropertyPath:next
			-> { name: resource, property: next}
		|	LambdaMethodCall: lambda
			-> { name: resource, lambda: lambda}
		)
	,
	Key =
		'('
		KeyBind:key
		')'
		-> key
	,
	KeyBind =
			NumberBind
		|	QuotedTextBind
	,
	ExternalKeyBind =
		KeyBind:b
		-> this.getBind(b)
	,
	Links =
		seq('/$links')
		SubPathSegment:link
		-> link
	,
	PathSegment =
		(	'/'
			ResourceName:resource
			(	Key:key
				(	Links:link
				|	SubPathSegment:next
				)?
			|	(	seq('/$count')
					-> true
				)?:count
			)?
		|	ContentReference:ref
			{ref.resource}:resource
			{ref.key}:key
			(	Links:link
			|	SubPathSegment:next
			)?
		)
		QueryOptions?:options
		-> { resource: resource, key: key, link: link, property: next, count: count, options: options }
	,
	SubPathSegment =
		'/'
		ResourceName:resource
		// Really this is only optional if the multiplicity from the previous segment to this segment is at most 1
		Key?:key
		(	seq('/$links')
			SubPathSegment:link
		|	SubPathSegment:next
		)?
		(	seq('/$count')
			-> true
		)?:count
		QueryOptions?:options
		-> { resource: resource, key: key, link: link, property: next, count: count, options: options }
	,

	ContentType =
		<	letter+
			'/'
			letter+
			('+' letter+)?
		>
	,

	ResourceName =
		<	(
				~(ReservedUriComponent | space)
				anything
			)+
		>:resourceName
		-> decodeURIComponent(resourceName)
	,

	Number =
			Decimal
		|	Integer
	,

	Decimal =
		Sign:sign
		<	digit+
			'.'
			digit+
		>:d
		-> Number(sign + d)
	,

	Integer =
		Sign:sign
		<digit+>:d
		-> parseInt(sign + d, 10)
	,

	UnsignedInteger =
		<digit+>:d
		-> parseInt(d, 10)
	,

	Null =
		seq('null')
		-> null
	,

	Boolean =
			True
		|	False
	,

	True =
		seq('true')
		-> true
	,

	False =
		seq('false')
		-> false
	,

	Duration =
		seq('duration')
		Apostrophe
		// Sign must appear first if it appears
		Sign:sign
		// P must always appear
		'P'
		// The order of elements is fixed (PnDTnHnMnS)
		DurationInteger('D')?:day
		(	// T must be present for time parts to be specified
			'T'
			DurationInteger('H')?:hour
			DurationInteger('M')?:minute
			DurationNumber('S')?:second
			// If T is present there must be a time part
			?(hour || minute || second)
		)?:timeExists
		// There must be a duration part
		?(day || timeExists)
		Apostrophe
		-> {
			negative: sign == '-',
			day: day,
			hour: hour,
			minute: minute,
			second: second
		}
	,
	DurationInteger :letter =
		UnsignedInteger:n
		exactly(letter)
		-> n
	,
	DurationNumber :letter =
		(	DurationInteger(letter)
		|	<	digit+
				'.'
				digit+
			>:d
			exactly(letter)
			-> Number(d)
		)
	,

	ReservedUriComponent =
			// GenDelim
			':' | '/' | '?' | '#' | '[' | ']' | '@'
		|
			// SubDelim
			'!' | '$' | '*' | '&' | '(' | ')' | '+' | ',' | ';' | '=' |
			// Apostrophe
			'\'' | seq('%27') -> '\''
	,

	Text =
		<	(	~ReservedUriComponent
				anything
			)*
		>:text
		-> decodeURIComponent(text)
	,

	Sign =
			'+'
		|	seq('%2B')
			-> '+'
		|	'-'
		|	-> ''
	,

	// TODO: This should really be done treating everything the same, but for now this hack should allow FF to work passably.
	Apostrophe =
			'\''
		|	seq('%27')
			-> '\''
	,

	Dollar =
		'$'
	|	seq('%24')
	,

	QuotedText =
		Apostrophe
		(	Apostrophe Apostrophe
		|	~Apostrophe
			anything
		)*:text
		Apostrophe
		-> decodeURIComponent(text.join(''))
	,

	Bind :type :value =
		{this.binds.push([type, value])}
		-> { bind: this.binds.length - 1 }
	,

	NumberBind =
		Number:n
		Bind('Real', n)
	,

	DateBind =
		(	seq('datetime')
			-> 'Date Time'
		|	seq('date')
			-> 'Date'
		):type
		QuotedText:date
		{Date.parse(date)}:date
		?(!isNaN(date))
		Bind(type, date)
	,

	BooleanBind =
		Boolean:b
		Bind('Boolean', b)
	,

	ContentReference =
		'$'
		ResourceName:resource
		Bind('ContentReference', resource):bind
		-> ({ resource: bind, key: bind })
	,

	QuotedTextBind =
		QuotedText:t
		Bind('Text', t)
}

ODataParser.initialize = ODataParser.reset = function() {
	this.binds = [];
};

ODataParser.ParseOptionsObject = function(options) {
	var optionsObj = {};
	for(var i in options) {
		optionsObj[options[i].name] = options[i].value;
	}
	return optionsObj;
};

ODataParser.space = function() {
	var r = this._apply('char');
	if (r.charCodeAt(0) <= 32) {
		return r;
	} else if (r === '%') {
		this._applyWithArgs("exactly", "2");
		this._applyWithArgs("exactly", "0");
		return " "
	} else {
		throw this._fail();
	}
};

ODataParser.numberOf = function(rule, count, separator) {
	if(count.length) {
		count.sort();
		// We need to check in descending order to make sure we match the most possible
		var origInput = this.input;
		for (var i = count.length - 1; i >= 0; i--) {
			try {
				this.input = origInput;
				return this.numberOf(rule, count[i], separator);
			} catch (e) {
				if (!(e instanceof SyntaxError)) {
					throw e;
				}
			}
		}
		throw this._fail()
	}
	if(count === 0) {
		return [];
	}
	var ret = [];
	for(var i = 1; i < count; i++) {
		ret.push(this._apply(rule));
		this._apply('spaces');
		this._applyWithArgs('exactly', separator);
		this._apply('spaces');
	}
	ret.push(this._apply(rule));
	return ret;
};

ODataParser.getBind = function(key) {
	return this.binds[key.bind]
};

ODataParser._enableTokens = function() {
	OMeta._enableTokens.call(this, ['Text', 'ResourceName', 'Number', 'RecognisedOption', 'FilterAndOperand', 'FilterByOperand', 'FilterRecognisedMathOperand']);
};
